# Завдання 1: Алгоритми однозв'язного списку

Цей код містить програмну реалізацію ключових алгоритмів для однозв'язних списків. Основна увага приділена ефективному керуванню вказівниками та роботі з пам'яттю "на місці" (**in-place**).

---

## Реалізований функціонал

### 1. Реверсування списку (`reverse`)

* **Механізм:** Алгоритм ітеративно переставляє вказівник `next` кожного вузла на попередній елемент.
* **Складність:** * Часова: $O(n)$
  * Просторова: $O(1)$
* **Особливість:** Коректно обробляє порожні списки та списки з одного елемента.

### 2. Сортування вставками (`insertion_sort`)

* **Механізм:** Вузли переміщуються з оригінального списку до нової відсортованої структури шляхом перев'язки посилань.
* **Складність:** * Часова: $O(n^2)$
  * Просторова: $O(1)$
* **Особливість:** Реалізовано "in-place", тобто нові об'єкти вузлів не створюються, змінюється лише їхній порядок.

### 3. Об'єднання відсортованих списків (`merge_sorted_lists`)

* **Механізм:** Використовує стратегію "Dummy Node" для лінійного порівняння та злиття двох впорядкованих послідовностей.
* **Складність:** $O(n + m)$, де $n$ та $m$ — довжини вхідних списків.

---

## Використання

1. Перейдіть до кореневої папки проєкту.
2. Запустіть скрипт командою:

    ```bash
    python linked_list_algorithms.py
    ```

3. Результати всіх операцій (початковий стан, реверс, сортування та злиття) відобразяться у консолі.

---

## Технічні деталі реалізації

* **In-place операції:** Усі алгоритми маніпулюють виключно посиланнями вузлів (`next`), що забезпечує просторову складність $O(1)$.
* **Dummy Node:** Використання фіктивного вузла у функції злиття спрощує логіку обробки початку списку та запобігає помилкам порожніх посилань.
* **Сортування:** Використано допоміжний метод `_sorted_insert` для підтримки чистоти коду (принцип **DRY** — Don't Repeat Yourself).

---

## Висновки

Реалізовані алгоритми демонструють базові принципи роботи з динамічними структурами даних. Ручне керування вказівниками забезпечує максимальну продуктивність та ефективність використання пам'яті, що є критично важливим для низькорівневої розробки.

---

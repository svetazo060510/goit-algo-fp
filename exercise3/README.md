# Завдання 3: Алгоритм Дейкстри з бінарною купою

Це завдання демонструє реалізацію класичного алгоритму пошуку найкоротших шляхів у зваженому графі з використанням пріоритетної черги для оптимізації.

---

## Опис алгоритму

Алгоритм Дейкстри знаходить найкоротші шляхи від однієї вершини до всіх інших у графі з невід'ємними вагами ребер.

Стандартна реалізація Дейкстри з перебором усіх вершин має складність $O(V^2)$. Використання бінарної купи (через бібліотеку `heapq`) дозволяє:

* **Швидко знаходити мінімум:** операція `heappop` виконується за $O(\log V)$.
* **Ефективно оновлювати відстані:** додавання нових значень у купу (`heappush`) також займає $O(\log V)$.
* **Загальна складність:** $O((E + V) \log V)$, що робить алгоритм надзвичайно ефективним для розріджених графів (де кількість ребер $E$ не набагато більша за кількість вершин $V$).

---

## Реалізація у проєкті

Для тестування було створено модель транспортної мережі міста:

* **Вузли:** Вузли: Важливі локації, такі як Центр, Школа, Супермаркет, Ресторан, Парк, Готель, Залізничний вокзал та Автовокзал.
* **Ваги:** Час у дорозі в хвилинах.
* **Оптімізація:** Алгоритм автоматично знаходить найшвидший маршрут, враховуючи всі можливі пересадки та розгалуження.

### Ключові функції

1. **`dijkstra(graph, start)`**: Основне ядро обчислень. Використовує словник для зберігання відстаней та купу для вибору наступної вершини.
2. **`get_path(predecessors, target)`**: Допоміжна функція, яка "розкручує" ланцюжок попередників для відновлення повного маршруту.

---
